# Java 乃至Java 程序内的一切都是对象

2.1用句柄操作对象 use handle to operate object
每种编程语言都有自己的数据处理方式

有些时候，程序员必须时刻留意准备处理的是什么类型。您曾利用
一些特殊语法直接操作过对象，或处理过一些间接表示的对象吗（C 或C++里的指针）？
所有这些在 Java 里都得到了简化，任何东西都可看作对象。因此，我们可采用一种统一的语法，任何地方均
可照搬不误。但要注意，尽管将一切都“看作”对象，但操纵的标识符实际是指向一个对象的“句柄”（Handle）

 对象保存在什么地方？
 (1) 寄存器。这是最快的保存区域，因为它位于和其他所有保存方式不同的地方：处理器内部。然而，寄存
器的数量十分有限，所以寄存器是根据需要由编译器分配。我们对此没有直接的控制权，也不可能在自己的
程序里找到寄存器存在的任何踪迹。
(2) 堆栈。驻留于常规 RAM（随机访问存储器）区域，但可通过它的“堆栈指针”获得处理的直接支持。堆
栈指针若向下移，会创建新的内存；若向上移，则会释放那些内存。这是一种特别快、特别有效的数据保存
方式，仅次于寄存器。创建程序时，Java 编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存
在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。这一限制无疑影响了程序的灵活
性，所以尽管有些Java 数据要保存在堆栈里——特别是对象句柄，但Java 对象并不放到其中。
(3) 堆。一种常规用途的内存池（也在 RAM区域），其中保存了Java 对象。和堆栈不同，“内存堆”或
“堆”（Heap）最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要
在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new命
令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然
会付出一定的代价：在堆里分配存储空间时会花掉更长的时间！
(4) 静态存储。这儿的“静态”（Static）是指“位于固定位置”（尽管也在 RAM里）。程序运行期间，静
态存储的数据将随时等候调用。可用static 关键字指出一个对象的特定元素是静态的。但 Java 对象本身永
远都不会置入静态存储空间。
(5) 常数存储。常数值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。有的常数
需要严格地保护，所以可考虑将它们置入只读存储器（ROM）。
(6) 非RAM 存储。若数据完全独立于一个程序之外，则程序不运行时仍可存在，并在程序的控制范围之外。
其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象，对象会变成字节流，通常会发给
另一台机器。而对于固定对象，对象保存在磁盘中。即使程序中止运行，它们仍可保持自己的状态不变。对
于这些类型的数据存储，一个特别有用的技巧就是它们能存在于其他媒体中。一旦需要，甚至能将它们恢复
成普通的、基于RAM的对象。

new将对象置于堆里。
有一系列类需特别对待；可将它们想象成“基本”、“主要”或者“主”（Primitive）类型，进行程序设计
时要频繁用到它们。之所以要特别对待，是由于用 new创建对象（特别是小的、简单的变量）并不是非常有
效，因为new将对象置于“堆”里。

Java 决定了每种主要类型的大小。就象在大多数语言里那样，这些大小并不随着机器结构的变化而变化。这
种大小的不可更改正是 Java 程序具有很强移植能力的原因之一。

Java 1.1 增加了两个类，用于进行高精度的计算：BigInteger和 BigDecimal，没有对应的主类型。
这两个类都有自己特殊的“方法”，对应于我们针对主类型执行的操作。也就是说，能对int或 float做的
事情，对BigInteger 和BigDecimal 一样可以做。只是必须使用方法调用，不能使用运算符。此外，由于牵
涉更多，所以运算速度会慢一些。我们牺牲了速度，但换来了精度。
BigInteger支持任意精度的整数。也就是说，我们可精确表示任意大小的整数值，同时在运算过程中不会丢
失任何信息。
BigDecimal支持任意精度的定点数字。例如，可用它进行精确的币值计算。
至于调用这两个类时可选用的构建器和方法，请自行参考联机帮助文档。

eg:主类型int，封装器类型Integer。


Java的数组

在C和 C++里使用数组是非常危险的，因为那些数组只是内存块。
但是在Java中做了特别的处理：
Java 的一项主要设计目标就是安全性。所以在C 和 C++里困扰程序员的许多问题都未在Java 里重复。一个
Java 可以保证被初始化，而且不可在它的范围之外访问。由于系统自动进行范围检查，所以必然要付出一些
代价：针对每个数组，以及在运行期间对索引的校验，都会造成少量的内存开销。但由此换回的是更高的安
全性，以及更高的工作效率。为此付出少许代价是值得的。

创建数组时：
创建对象数组时，实际创建的是一个句柄数组。而且每个句柄都会自动初始化成一个特殊值，并带有自己的
关键字：null（空）。一旦 Java 看到null，就知道该句柄并未指向一个对象。正式使用前，必须为每个句
柄都分配一个对象。若试图使用依然为null 的一个句柄，就会在运行期报告问题。因此，典型的数组错误在
Java 里就得到了避免。

