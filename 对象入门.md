# Java-
终于，今天要读一下Java编程思想笔记了，打算每天至少精读25页，并摘录关于里边的优秀思想。

Chapter1 对象入门
思考对象的时候，需要采用形象思维，而不是程序化的思维。对象的设计过程更具挑战性，特别
是在尝试创建可重复（可再生）的对象时。

1.1抽象的进步
解决问题的复杂程度直接取决于抽象的种类及质量，种类是指准备对什么进行抽象。
汇编语言抽象基础机器，命令式语言抽象汇编语言，这些抽象原理必须着重考虑计算机
的结构，而非考虑问题本身的结构。
在机器模型（位于“方案空间”）与实际解决的问题模型（位于“问题空间”）之间，程序员必须建立
起一种联系，所以程序员必须付出极大的精力。

面向对象的程序设计在此基础上则跨出了一大步，程序员可利用一些工具表达问题空间内的元素。由于这种
表达非常普遍，所以不必受限于特定类型的问题。我们将问题空间中的元素以及它们在方案空间的表示物称
作“对象”（Object）。

OOP允许我们根据问题来描述问题，而不是根据方案。
然而，仍有一个联系途径回到计算机。每个对象都类似一台小计算机；
它们有自己的状态，而且可要求它们进行特定的操作。与现实世界的“对象”或者“物体”相比，编程“对
象”与它们也存在共通的地方：它们都有自己的特征和行为。

面向对象程序设计的方法5个：
（1）万物皆对象，可以将对象想象成一种新型类型，它保存着数据，但可要求它对自身进行操作。
理论上讲，可从要解决的问题身上提出所有概念性的组件，然后在程序中将其表达为一个对象。
（2）程序是一大堆对象的组合；通过消息传递，各对象知道自己该做些什么。为了向对象发出请求，需向那
个对象“发送一条消息”。更具体地讲，可将消息想象为一个调用请求，它调用的是从属于目标对象的一个
子例程或函数。
（3）每个对象都有自己的存储空间，可容纳其他对象。或者说，通过封装现有对象，可制作出新型对象。所
以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂程度。
（4）每个对象都有一种类型。根据语法，每个对象都是某个“类”的一个“实例”。其中，“类”（Class）
是“类型”（Type）的同义词。一个类最重要的特征就是“能将什么消息发给它？”。
（5）同一类所有对象都能接收相同的消息。这实际是别有含义的一种说法，大家不久便能理解。由于类型为
“圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收形状消
息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括
“圆”。这一特性称为对象的“可替换性”，是OOP最重要的概念之一。

1.2对象的接口
所有对象——尽管各有特色——都属于某一系列对象的一部分，这些对象具有通用的特征和行为。

Simula是一个很好的例子。正如这个名字所暗示的，它的作用是“模拟”（Simulate）象“银行出纳员”这
样的经典问题。在这个例子里，我们有一系列出纳员、客户、帐号以及交易等。每类成员（元素）都具有一
些通用的特征：每个帐号都有一定的余额；每名出纳都能接收客户的存款；等等。与此同时，每个成员都有
自己的状态；每个帐号都有不同的余额；每名出纳都有一个名字。所以在计算机程序中，能用独一无二的实
体分别表示出纳员、客户、帐号以及交易。这个实体便是“对象”，而且每个对象都隶属一个特定的
“类”，那个类具有自己的通用特征与行为。

如何利用对象完成真正有用的工作呢？

必须有一种办法能向对象发出请求，令其做一些实际的事情，比如完
成一次交易、在屏幕上画一些东西或者打开一个开关等等。每个对象仅能接受特定的请求。我们向对象发出
的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。

“类型”与“接口”的等价或对应关系是面向对象程序设计的基础。

Light lt = new Light();
lt.on();
用new关键字新建类型为 Light 的一个对象。再用等号将其赋给句柄。为了向对象发
送一条消息，我们列出句柄名（lt），再用一个句点符号（.）把它同消息名称（on）连接起来。从中可以看
出，使用一些预先定义好的类时，我们在程序里采用的代码是非常简单和直观的。

1.3实现方案的隐藏
涉及面向对象的编程人员有两种，一是类创建者，二是客户程序员。

对客户程序员来讲，最主要的目标就是收集一个充斥着各种类的编程“工具
箱”，以便快速开发符合自己要求的应用。而对类创建者来说，他们的目标则是从头构建一个类，只向客户
程序员开放有必要开放的东西（接口），其他所有细节都隐藏起来。为什么要这样做？隐藏之后，客户程序
员就不能接触和改变那些细节，所以原创者不用担心自己的作品会受到非法修改，可确保它们不会对其他人
造成影响。

“接口”（Interface）规定了可对一个特定的对象发出哪些请求。

这里讲到了public private protected friendly，控制客户程序员对成员的访问。

1.4方案的重复使用
1.5继承：重新使用接口

就其本身来说，对象的概念可为我们带来极大的便利。它在概念上允许我们将各式各样数据和功能封装到一
起。这样便可恰当表达“问题空间”的概念，不用刻意遵照基础机器的表达方式。在程序设计语言中，这些
概念则反映为具体的数据类型（使用class 关键字）。

继承并不完全等价于克隆。在继承过程中，若原始类（正式名称叫作基础类、超类或父类）发生了变化，
修改过的“克隆”类（正式名称叫作继承类或者子类）也会反映出这种变化。

可向基础类的对象发送的所有消息亦可原样发给衍生类的对象。
根据可以发送的消息，我们能知道类的类型。这意味着衍生类具有与基础类相同的类型！
为真正理解面向对象程序设计的含义，首先必须认识到这种类型的等价关系。

1.5.1改善基础类

继续器”（Iterator），它属于一种对象，负责选择集合内的元素，并把它们提供给继
承器的用户。作为一个类，它也提供了一级抽象。利用这一级抽象，可将集合细节与用于访问那个集合的代
码隔离开。通过继承器的作用，集合被抽象成一个简单的序列。继承器允许我们遍历那个序列，同时毋需关
心基础结构是什么——换言之，不管它是一个矢量、一个链接列表、一个堆栈，还是其他什么东西。这样一
来，我们就可以灵活地改变基础数据，不会对程序里的代码造成干扰。

1.7.2单根结构
在Java 中（与其他几乎所有OOP语言一样），对这个问题的答案都是肯定的，而且这个终级基
础类的名字很简单，就是一个“Object”。这种“单根结构”具有许多方面的优点。

单根结构中的所有对象（比如所有 Java 对象）都可以保证拥有一些特定的功能。在自己的系统中，我们知道
对每个对象都能进行一些基本操作。一个单根结构，加上所有对象都在内存堆中创建，可以极大简化参数的
传递（这在 C++里是一个复杂的概念）。

利用单根结构，我们可以更方便地实现一个垃圾收集器。与此有关的必要支持可安装于基础类中，而垃圾收
集器可将适当的消息发给系统内的任何对象。如果没有这种单根结构，而且系统通过一个句柄来操纵对象，
那么实现垃圾收集器的途径会有很大的不同，而且会面临许多障碍。
由于运行期的类型信息肯定存在于所有对象中，所以永远不会遇到判断不出一个对象的类型的情况。

为什么C++没有采用单根结构呢？事实上，这是
早期在效率与控制上权衡的一种结果。单根结构会带来程序设计上的一些限制。而且更重要的是，它加大了
新程序与原有C 代码兼容的难度。尽管这些限制仅在特定的场合会真的造成问题，但为了获得最大的灵活程
度，C++最终决定放弃采用单根结构这一做法。而 Java 不存在上述的问题，它是全新设计的一种语言，不必
与现有的语言保持所谓的“向后兼容”。所以很自然地，与其他大多数面向对象的程序设计语言一样，单根
结构在Java 的设计方案中很快就落实下来。

1.7.4 清除时的困境：由谁负责清除？
每个对象都要求资源才能“生存”，其中最令人注目的资源是内存。如果不再需要使用一个对象，就必须将
其清除，以便释放这些资源，以便其他对象使用。如果要解决的是非常简单的问题，如何清除对象这个问题
并不显得很突出：我们创建对象，在需要的时候调用它，然后将其清除或者“破坏”。但在另一方面，我们
平时遇到的问题往往要比这复杂得多。

如何才能知道什么时间删除对象呢？

垃圾收集器“知道”一个对象在什么时候不再使用，然后会自动释放那个对象占据的内存空间。采用
这种方式，另外加上所有对象都从单个根类Object 继承的事实，而且由于我们只能在内存堆中以一种方式创
建对象，所以Java 的编程要比 C++的编程简单得多。

Java 比C++简单，但付出的代价是效率以及一定程度的灵活性。但对大多数程序设计问题来说，
Java 无疑都应是我们的首选。

1.8违例控制
Java 的违例控制机制与大多数程序设计语言都有所不同。因为在Java 中，违例控制模块是从一开始就封装
好的，所以必须使用它！如果没有自己写一些代码来正确地控制违例，就会得到一条编译期出错提示。这样
可保证程序的连贯性，使错误控制变得更加容易。


